# Vulnerability Remediation Guide

This guide explains how to identify, understand, and fix security vulnerabilities found by GitHub's security analysis tools.

---

## Understanding Security Alerts

### Severity Levels

GitHub categorizes vulnerabilities by severity:

- **Critical**: Immediate action required - can lead to complete system compromise
- **High**: Should be fixed soon - significant security risk
- **Medium**: Should be addressed - moderate security risk
- **Low**: Consider fixing - minor security risk

### Types of Vulnerabilities

1. **Dependency Vulnerabilities**: Issues in third-party packages
2. **Code Vulnerabilities**: Issues in your source code
3. **Secret Exposure**: Accidental commit of API keys, passwords, etc.

---

## Step 1: Review Security Alerts

### 1.1 Access Security Alerts

1. Go to your GitHub repository
2. Click **Security** tab
3. Review alerts in:
   - **Dependabot alerts**: Dependency vulnerabilities
   - **Code scanning alerts**: Code-level issues
   - **Secret scanning**: Exposed secrets

### 1.2 Understand the Alert

For each alert, review:
- **Severity**: How critical is this?
- **Description**: What's the problem?
- **Affected Code**: Where is the issue?
- **CVE Details**: If applicable, Common Vulnerabilities and Exposures info
- **Recommended Fix**: Suggested solution

---

## Step 2: Fix Dependency Vulnerabilities

### 2.1 Using Dependabot PRs (Recommended)

1. **Review the PR**:
   - Dependabot creates PRs automatically
   - Review the changes
   - Check if update breaks anything

2. **Test the Update**:
   ```bash
   # Checkout the Dependabot branch
   git checkout dependabot/nuget/package-name
   
   # Restore and build
   dotnet restore
   dotnet build
   
   # Run your tests
   dotnet test
   ```

3. **Merge the PR**:
   - If tests pass, merge the PR
   - Dependabot will close the alert automatically

### 2.2 Manual Package Update

If Dependabot PR is not available:

1. **Check Current Version**:
   ```bash
   dotnet list package --vulnerable
   ```

2. **Find Latest Version**:
   - Visit NuGet.org
   - Search for the package
   - Check latest stable version

3. **Update the Package**:
   ```bash
   # Update specific package
   dotnet add package PackageName --version LatestVersion
   
   # Or edit .csproj file directly
   ```

4. **Test and Commit**:
   ```bash
   dotnet restore
   dotnet build
   dotnet test
   git add .
   git commit -m "Security: Update PackageName to fix CVE-XXXX-XXXX"
   git push
   ```

### 2.3 Common Dependency Vulnerabilities

#### Entity Framework Core Updates

**Issue**: SQL injection vulnerabilities in older EF Core versions

**Fix**:
```xml
<!-- Update to latest version -->
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="8.0.0" />
```

#### ASP.NET Core Updates

**Issue**: Security patches in ASP.NET Core

**Fix**:
```xml
<!-- Update to latest patch version -->
<PackageReference Include="Microsoft.AspNetCore.Session" Version="2.2.0" />
```

#### Cryptography Updates

**Issue**: Weak encryption algorithms

**Fix**:
```xml
<!-- Ensure using latest secure version -->
<PackageReference Include="System.Security.Cryptography.Algorithms" Version="4.3.1" />
```

---

## Step 3: Fix Code-Level Vulnerabilities

### 3.1 SQL Injection Prevention

**CodeQL Alert**: "SQL query built from user-controlled sources"

**Current Implementation** (✅ Already Safe):
```csharp
// ✅ GOOD: Using Entity Framework (parameterized queries)
var member = await _context.Members
    .FirstOrDefaultAsync(m => m.Email == email);
```

**If You See This Alert**:
- Verify you're using EF Core (not raw SQL)
- Check that all queries use LINQ or parameterized queries
- Never concatenate user input into SQL strings

**Example Fix**:
```csharp
// ❌ BAD: Raw SQL with string concatenation
var sql = $"SELECT * FROM Members WHERE Email = '{email}'";

// ✅ GOOD: Parameterized query
var member = await _context.Members
    .FirstOrDefaultAsync(m => m.Email == email);
```

### 3.2 XSS Prevention

**CodeQL Alert**: "User-controlled data in HTML output"

**Current Implementation** (✅ Already Safe):
```csharp
// ✅ GOOD: HTML encoding in InputSanitizationService
input = WebUtility.HtmlEncode(input);
```

**If You See This Alert**:
- Ensure all user input is HTML-encoded before display
- Use Razor's automatic encoding: `@Model.Email` (not `@Html.Raw(Model.Email)`)
- Verify `InputSanitizationService` is used everywhere

**Example Fix**:
```csharp
// ❌ BAD: Raw HTML output
@Html.Raw(Model.UserInput)

// ✅ GOOD: Automatic HTML encoding
@Model.UserInput
```

### 3.3 Sensitive Data Exposure

**CodeQL Alert**: "Hard-coded credentials or secrets"

**Current Implementation** (✅ Already Safe):
- Secrets in `appsettings.json` (excluded from Git)
- Encryption keys not hardcoded

**If You See This Alert**:
1. **Remove hardcoded secrets**:
   ```csharp
   // ❌ BAD
   var apiKey = "hardcoded-key-12345";
   
   // ✅ GOOD
   var apiKey = _configuration["ApiKey"];
   ```

2. **Use Environment Variables**:
   ```csharp
   // ✅ GOOD: From configuration
   var encryptionKey = _configuration["Encryption:Key"];
   ```

3. **Use GitHub Secrets** (for CI/CD):
   - Go to repository Settings → Secrets
   - Add secrets there
   - Reference in workflows: `${{ secrets.SECRET_NAME }}`

### 3.4 Weak Cryptography

**CodeQL Alert**: "Use of weak cryptographic algorithm"

**Current Implementation** (✅ Already Safe):
- SHA-256 for password hashing
- AES-256 for encryption

**If You See This Alert**:
- Never use MD5, SHA1, or DES
- Use SHA-256 or better for hashing
- Use AES-256 or better for encryption

**Example Fix**:
```csharp
// ❌ BAD: Weak algorithm
using (var md5 = MD5.Create()) { ... }

// ✅ GOOD: Strong algorithm
using (var sha256 = SHA256.Create()) { ... }
```

### 3.5 Insecure Random Number Generation

**CodeQL Alert**: "Use of cryptographically weak random number generator"

**Current Implementation** (✅ Already Safe):
- Using `Guid.NewGuid()` for tokens (cryptographically secure)

**If You See This Alert**:
```csharp
// ❌ BAD: Weak random
var random = new Random();
var token = random.Next().ToString();

// ✅ GOOD: Cryptographically secure
var token = Guid.NewGuid().ToString();
// Or
using (var rng = RandomNumberGenerator.Create())
{
    var bytes = new byte[32];
    rng.GetBytes(bytes);
    var token = Convert.ToBase64String(bytes);
}
```

---

## Step 4: Fix Secret Exposure

### 4.1 If Secrets Are Found

**Immediate Actions**:
1. **Rotate the Secret**: Change the exposed key/password immediately
2. **Remove from Git History**:
   ```bash
   # Use git-filter-repo or BFG Repo-Cleaner
   # Or create new repository without secrets
   ```
3. **Update .gitignore**: Ensure secrets are excluded
4. **Use Environment Variables**: Move secrets to environment variables

### 4.2 Prevent Future Exposure

1. **Review .gitignore**:
   - Ensure `appsettings.json` is excluded
   - Add patterns for other sensitive files

2. **Use Example Files**:
   - Commit `appsettings.Example.json`
   - Document required configuration

3. **Pre-commit Hooks**:
   - Use tools like `git-secrets` to prevent commits

---

## Step 5: Verify Fixes

### 5.1 Test After Fixing

1. **Build the Project**:
   ```bash
   dotnet build
   ```

2. **Run Tests**:
   ```bash
   dotnet test
   ```

3. **Manual Testing**:
   - Test the affected functionality
   - Verify security fix works
   - Ensure no regressions

### 5.2 Re-scan After Fix

1. **Push Changes**:
   ```bash
   git add .
   git commit -m "Security: Fix [vulnerability description]"
   git push
   ```

2. **Wait for Scan**:
   - GitHub automatically re-scans on push
   - Usually completes within minutes

3. **Verify Alert is Closed**:
   - Go to Security tab
   - Check that alert is marked as "Fixed" or "Dismissed"

---

## Step 6: Dismiss False Positives

Sometimes CodeQL may flag code that is actually safe.

### 6.1 When to Dismiss

- Code is safe but CodeQL can't verify it
- False positive confirmed after review
- Acceptable risk for your use case

### 6.2 How to Dismiss

1. Go to the alert in Security tab
2. Click **Dismiss**
3. Select reason:
   - **False positive**: Not a real issue
   - **Won't fix**: Acceptable risk
   - **Used in tests**: Only in test code
4. Add comment explaining why
5. Click **Dismiss alert**

---

## Common Vulnerability Patterns and Fixes

### Pattern 1: SQL Injection

**Alert**: "SQL query built from user-controlled sources"

**Fix**: Always use parameterized queries (EF Core does this automatically)

### Pattern 2: XSS

**Alert**: "User-controlled data in HTML output"

**Fix**: HTML encode all user input before display

### Pattern 3: Path Traversal

**Alert**: "Path traversal vulnerability"

**Fix**: Validate and sanitize file paths, use `Path.GetFileName()`

### Pattern 4: Insecure Deserialization

**Alert**: "Insecure deserialization"

**Fix**: Use safe deserialization methods, validate input

### Pattern 5: Weak Password Policy

**Alert**: "Weak password requirements"

**Fix**: Enforce strong passwords (already implemented ✅)

---

## Priority Matrix

Use this to prioritize fixes:

| Severity | Action | Timeline |
|----------|--------|----------|
| Critical | Fix immediately | Within 24 hours |
| High | Fix soon | Within 7 days |
| Medium | Plan fix | Within 30 days |
| Low | Consider fixing | Next release |

---

## Best Practices

1. **Regular Reviews**: Check security alerts weekly
2. **Automated Updates**: Enable Dependabot auto-merge for low-risk updates
3. **Test Before Merge**: Always test security updates
4. **Document Fixes**: Comment why code is safe if dismissing
5. **Stay Updated**: Keep dependencies current
6. **Monitor CVEs**: Subscribe to security advisories

---

## Resources

- [GitHub Security Advisories](https://docs.github.com/en/code-security/security-advisories)
- [CodeQL Query Help](https://codeql.github.com/docs/)
- [.NET Security Best Practices](https://learn.microsoft.com/en-us/dotnet/standard/security/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)

---

**Last Updated**: 2026-02-05
